# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/169Qg5xKAOFwaMkDYQeXCpmOkqs9mns8h
"""

import random
from PIL import Image,ImageDraw
from concurrent.futures import ProcessPoolExecutor
import numpy as np
import matplotlib.pyplot as plt

def generar_punto_aleatorio(ancho_imagen, alto_imagen):
    x = random.randint(0, ancho_imagen - 1)
    y = random.randint(0, alto_imagen - 1)
    radio = random.randint(1, 5)  # por ejemplo, un radio aleatorio entre 1 y 5

    r = random.randint(0, 255)
    g = random.randint(0, 255)
    b = random.randint(0, 255)
    return (x, y,radio, r, g, b)

def generar_punto_fijo(ancho_imagen, alto_imagen):
    x = random.randint(0, ancho_imagen - 1)
    y = random.randint(0, alto_imagen - 1)
    radio = random.randint(1, 5)
    return (x, y, radio)

def generar_poblacion_secuencial(tam_poblacion, num_puntos, ancho_imagen, alto_imagen):
    distancia = int(np.sqrt(ancho_imagen * alto_imagen / num_puntos))
    poblacion = []

    for _ in range(tam_poblacion):
        individuo = []
        for x in range(0, ancho_imagen, distancia):
            for y in range(0, alto_imagen, distancia):
                punto = (x, y, random.randint(1, 5))  # Agregado radio aleatorio
                color = color_aleatorio()
                individuo.append((punto, color))
        poblacion.append(individuo)
    
    return poblacion

def color_aleatorio():
    r = random.randint(0, 255)
    g = random.randint(0, 255)
    b = random.randint(0, 255)
    return (r, g, b)


def generar_individuo(num_puntos, ancho_imagen, alto_imagen):
    puntos_fijos = [generar_punto_fijo(ancho_imagen, alto_imagen) for _ in range(num_puntos)]
    colores = [color_aleatorio() for _ in range(num_puntos)]
    return list(zip(puntos_fijos, colores))

def generar_poblacion(tam_poblacion, num_puntos, ancho_imagen, alto_imagen):
    return [generar_individuo(num_puntos, ancho_imagen, alto_imagen) for _ in range(tam_poblacion)]

def individuo_a_imagen(individuo, ancho_imagen, alto_imagen):
    imagen = Image.new('RGB', (ancho_imagen, alto_imagen))
    draw = ImageDraw.Draw(imagen)

    for punto_fijo, color in individuo:
        x, y, radio = punto_fijo
        draw.ellipse([(x-radio, y-radio), (x+radio, y+radio)], fill=color)

    return imagen

def calcular_fitness_envoltura(args):
    return fitness(*args)

def calcular_diferencia(imagen1, imagen2):
    # Convertir imágenes a arrays de Numpy
    arr1 = np.asarray(imagen1)
    arr2 = np.asarray(imagen2)

    # Calcular la diferencia y sumarla
    diferencia = np.sum(np.abs(arr1 - arr2))

    return diferencia

def fitness(individuo, imagen_objetivo):
    imagen_generada = individuo_a_imagen(individuo, *imagen_objetivo.size)
    return calcular_diferencia(imagen_generada, imagen_objetivo)

def seleccion_torneo(poblacion, imagen_objetivo, tam_torneo=3):
    seleccionados = random.sample(poblacion, tam_torneo)
    seleccionados.sort(key=lambda ind: fitness(ind, imagen_objetivo))
    return seleccionados[0]

def cruzar(padre1, padre2):
    punto_corte = random.randint(0, len(padre1))
    hijo1 = padre1[:punto_corte] + padre2[punto_corte:]
    hijo2 = padre2[:punto_corte] + padre1[punto_corte:]
    return hijo1, hijo2

def mutar(individuo, probabilidad_mutacion):
    if random.random() < probabilidad_mutacion:
        indice = random.randint(0, len(individuo) - 1)
        _, color_actual = individuo[indice]
        nuevo_color = color_aleatorio()
        if color_actual != nuevo_color:
            individuo[indice] = (individuo[indice][0], nuevo_color)

# Nuestro algoritmo genético:
def algoritmo_genetico(imagen_objetivo_path, tam_poblacion, num_puntos, num_generaciones, probabilidad_mutacion, tam_torneo):
    imagen_objetivo = Image.open(imagen_objetivo_path)
    ancho_imagen, alto_imagen = imagen_objetivo.size

    poblacion  = generar_poblacion_secuencial(tam_poblacion, num_puntos, ancho_imagen, alto_imagen)


    mejor_individuo = min(poblacion, key=lambda ind: fitness(ind, imagen_objetivo))
    mejor_fitness = fitness(mejor_individuo, imagen_objetivo)

    for generacion in range(num_generaciones):
        nueva_poblacion = []

        while len(nueva_poblacion) < tam_poblacion:
            padre1 = seleccion_torneo(poblacion, imagen_objetivo, tam_torneo)
            padre2 = seleccion_torneo(poblacion, imagen_objetivo, tam_torneo)

            hijo1, hijo2 = cruzar(padre1, padre2)

            mutar(hijo1, probabilidad_mutacion)
            mutar(hijo2, probabilidad_mutacion)

            nueva_poblacion.append(hijo1)
            nueva_poblacion.append(hijo2)

        poblacion = nueva_poblacion

        individuo_actual = min(poblacion, key=lambda ind: fitness(ind, imagen_objetivo))
        fitness_actual = fitness(individuo_actual, imagen_objetivo)

        if fitness_actual < mejor_fitness:
            mejor_fitness = fitness_actual
            mejor_individuo = individuo_actual

        if generacion % 200 == 0:  # Muestra la imagen cada 5 generaciones
            resultado_temp = individuo_a_imagen(individuo_actual, ancho_imagen, alto_imagen)
            plt.imshow(resultado_temp)
            plt.title(f"Generación {generacion + 1}")
            plt.pause(1)  # Pausa por 1 segundo. Puedes ajustar esto según tus necesidades.



        print(f"Generación {generacion + 1}/{num_generaciones}, Mejor Fitness: {mejor_fitness}")

    return individuo_a_imagen(mejor_individuo, ancho_imagen, alto_imagen)

# Ejemplo de uso:
resultado = algoritmo_genetico("OIP.jpg", 100, 1000, 2000, 0.1, 3)
resultado.save("imagen_resultante.jpg")